import os
import glob

def get_master_ini_file():
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        ini_files = glob.glob(os.path.join(script_dir, "*.ini"))
        
        ini_files = [file for file in ini_files if os.path.basename(file).lower() != "desktop.ini"]

        if not ini_files:
            raise FileNotFoundError("No .ini file found in the script's folder.")
        
        print(f"Master .ini file found: {ini_files[0]}")
        return ini_files[0]
    except Exception as e:
        print(f"Error in get_master_ini_file: {e}")
        raise

def get_swapvar_and_namespace_from_master_ini(master_ini_path):
    try:
        swapvar_value = 0
        namespace = ""       
        with open(master_ini_path, 'r', encoding='utf-8') as f:
            in_keyswap_section = False
            for line in f:
                line = line.strip()
                
                if line.lower().startswith('[keyswap]'):
                    in_keyswap_section = True
                    continue

                if in_keyswap_section:
                    if "$swapvar" in line:
                        try:
                            # Get the existing swapvar values and determine the next available value
                            existing_values = line.split('=')[1].strip().split(',')
                            swapvar_value = max(map(int, existing_values)) + 1  # Find the max value and increment
                            print(f"Found existing swapvar values: {existing_values}. Next swapvar will be: {swapvar_value}")
                            break
                        except ValueError:
                            pass
                    
                if "namespace" in line.lower():
                    parts = line.split('=')  # Corrected to split by '='
                    if len(parts) == 2:
                        namespace = parts[1].strip()
                        print(f"Found namespace: {namespace}")
        
        return swapvar_value, namespace
    except Exception as e:
        print(f"Error in get_swapvar_and_namespace_from_master_ini: {e}")
        raise

def get_relative_path(file_path, base_dir):
    try:
        relative_path = os.path.relpath(file_path, base_dir).replace(os.sep, '/')
        return relative_path
    except Exception as e:
        print(f"Error in get_relative_path: {e}")
        raise

def process_ini_file(new_ini_path, swapvar_value, master_ini_path, base_dir, namespace):
    try:
        # Ensure we skip the master .ini file itself
        if os.path.abspath(new_ini_path) == os.path.abspath(master_ini_path):
            print(f"Skipping master .ini file: {new_ini_path}")
            return

        with open(new_ini_path, 'r', encoding='utf-8') as f:
            new_ini_content = f.readlines()

        updated_content = []
        Check_Empty_Lines = 0
        in_texture_override = False
        in_if_block = False
        match_priority_found = False
        if_block_found = False
        endif_found = False

        for i, line in enumerate(new_ini_content):
            stripped_line = line.strip()

            if in_texture_override:
                if 'match_priority' in stripped_line:
                    match_priority_found = True
                if 'if $\\{namespace}\\swapvar' in stripped_line:
                    if_block_found = True
                if stripped_line.lower() == 'endif':
                    endif_found = True

            if stripped_line.startswith('[TextureOverride'):
                match_priority_found = False
                if_block_found = False
                endif_found = False
                if in_if_block:
                    updated_content.append('endif\n\n')
                    in_if_block = False
                in_texture_override = True
                updated_content.append(line)
                continue

            if in_texture_override and stripped_line.startswith('hash ='):
                updated_content.append(line)
                if not match_priority_found:
                    updated_content.append(f'match_priority = {swapvar_value}\n')
                if not if_block_found:
                    updated_content.append(f'if $\\{namespace}\\swapvar == {swapvar_value}\n')
                    in_if_block = True
                continue

            if in_if_block:
                next_line = new_ini_content[i + 1].strip() if i + 1 < len(new_ini_content) else ''
                updated_content.append(f'    {line}')


                if not next_line and Check_Empty_Lines == 0:
                    next_lines = new_ini_content[i+1:i+4]  # Look ahead at the next 3 lines
                    for next_line in next_lines:
                        next_line = next_line.strip()
                        if next_line.startswith("["):  # New section begins, don't close block
                            break
                        elif next_line:  # Content exists after the empty line
                            Check_Empty_Lines = 1  # Indicate there is content
                            break

                if next_line.startswith('['):
                    updated_content.append('endif\n\n')
                    in_if_block = False
                    in_texture_override = False
           
                continue

            updated_content.append(line)

        if in_if_block:
            updated_content.append('endif\n\n')

        with open(new_ini_path, 'w', encoding='utf-8') as f:
            f.writelines(updated_content)

        with open(master_ini_path, 'r', encoding='utf-8') as f:
            master_ini_content = f.readlines()

        in_keyswap_section = False
        in_merged_mod_section = False
        new_relative_path = get_relative_path(new_ini_path, base_dir)

        new_relative_path = ".\\" + new_relative_path  # Correct this line

        for i, line in enumerate(master_ini_content):
            stripped_line = line.strip()

            if stripped_line.lower().startswith('[keyswap]'):
                in_keyswap_section = True
                continue

            if in_keyswap_section and '$swapvar' in stripped_line:
                existing_values = stripped_line.split('=')[1].strip().split(',')
                existing_values = list(map(str.strip, existing_values))
                if str(swapvar_value) not in existing_values:
                    existing_values.append(str(swapvar_value))
                master_ini_content[i] = f"$swapvar = {','.join(existing_values)}\n"
    
            if stripped_line.lower().startswith('; merged mod:'):
                in_merged_mod_section = True
                parts = line.split(':')[1].strip().split(',')
                if new_relative_path not in parts:
                    parts.append(new_relative_path)
                    master_ini_content[i] = f"; Merged Mod: {', '.join(parts)}\n"

        if not in_merged_mod_section:
            master_ini_content.append(f"; Merged Mod: {new_relative_path}\n")

        with open(master_ini_path, 'w', encoding='utf-8') as f:
            f.writelines(master_ini_content)

    except Exception as e:
        print(f"Error in process_ini_file: {e}")
        raise

def process_folder(folder_path):
    try:
        master_ini_path = get_master_ini_file()
        base_dir = os.path.dirname(master_ini_path)
        
        swapvar_value, namespace = get_swapvar_and_namespace_from_master_ini(master_ini_path)
        
        with open(master_ini_path, 'r', encoding='utf-8') as f:
            master_ini_content = f.readlines()

        # Extract all already added relative paths from the "Merged Mod" section
        added_files = []
        for line in master_ini_content:
            if 'Merged Mod:' in line:
                parts = line.split(':')[1].strip().split(',')
                added_files.extend([part.strip() for part in parts])
        
        # Normalize paths for comparison
        added_files = [os.path.normpath(os.path.join(base_dir, f.strip('.\\'))) for f in added_files if f.strip()]

        for root, dirs, files in os.walk(folder_path):
            # Skip disabled directories
            dirs[:] = [d for d in dirs if not d.lower().startswith('disabled')]
            files[:] = [f for f in files if not f.lower().startswith('disabled')]

            for file in files:
                if file.lower().endswith('.ini'):
                    new_ini_path = os.path.normpath(os.path.join(root, file))

                    # Skip desktop.ini
                    if file.lower() == 'desktop.ini' or file.lower().endswith('icon.ini') or file.lower().endswith('icons.ini'):
                        continue

                    if 'RemapFix' in file:
                        continue

                    # Skip if this is the master .ini file
                    if new_ini_path == master_ini_path:
                        continue

                    # Normalize the path for comparison
                    normalized_path = os.path.relpath(new_ini_path, base_dir).replace("\\", "/")
                    normalized_path_alt = os.path.relpath(new_ini_path, base_dir).replace("/", "\\")
            
                    if any(normalized_path in added_file or normalized_path_alt in added_file for added_file in added_files):
                        continue

                    print(f"Found new .ini file: {new_ini_path}")
                    user_input = input(f"Do you want to add this ini to the master (y/n)? ")
                    
                    if user_input.lower() == 'y':
                        process_ini_file(new_ini_path, swapvar_value, master_ini_path, base_dir, namespace)
                        swapvar_value += 1
    except Exception as e:
        print(f"Error in process_folder: {e}")
        raise


if __name__ == "__main__":
    print("Welcome to Skin_Adder Station Traveler!ðŸ˜Š")
    folder_path = os.path.dirname(os.path.abspath(__file__))
    process_folder(folder_path)
    print("Thanks for using this Skin_Adder Station Traveler!ðŸ˜Š")
    print("Press Enter to Exit...")
